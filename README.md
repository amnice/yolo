# Yolo Guide
## Requirements
Make sure that you have the following installed:
- [node](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04) 
- npm 
- [MongoDB](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/) and start the mongodb service with `sudo service mongod start`
- Navigate to the Client Folder 
 `cd client`
- Run the following command to install the dependencies 
 `npm install`
- Run the following to start the app
 `npm start`
- Open a new terminal and run the same commands in the backend folder
 `cd ../backend`
 `npm install`
 `npm start`


## Choice of Base Image

1. **Frontend Client (React):** For the frontend client, we chose the Node.js LTS version as the base image for building the application. We utilized the official Node.js Docker image, which provides a stable environment for running JavaScript applications.

2. **Backend Server (Node.js):** Similar to the frontend client, we opted for the Node.js LTS version as the base image for the backend server. We used the official Node.js Docker image to ensure compatibility and stability.

3. **MongoDB Database:** Instead of building a custom Docker image for MongoDB, we opted to use the official MongoDB Docker image available on Docker Hub. This image provides a pre-configured MongoDB database server, simplifying the setup process.

## Dockerfile Directives

1. **Multi-stage Builds:** To reduce image size and optimize build times, we utilized multi-stage builds in both the frontend and backend Dockerfiles. This approach allows us to separate the build environment from the production environment and ensures that the final image only includes necessary dependencies and artifacts.

2. **Copying Source Code:** We copied the application source code into the Docker image using the `COPY` directive. This includes copying the `package.json` and `package-lock.json` files to install dependencies and copying the rest of the application code.

3. **Dependency Installation:** We installed dependencies using the `npm install` command within the Dockerfile to ensure that all required packages are installed within the container environment.

4. **Build Process:** We executed the build process within the Dockerfile using the appropriate commands (`npm run build` for both the frontend client and backend server) to generate production-ready assets.

## Docker-Compose Networking

1. **Port Mapping:** We defined port mappings in the Docker Compose file to expose the necessary ports for communication between containers and with external clients. The frontend client listens on port 80, the backend server listens on port 3000, and MongoDB listens on port 27017.

2. **Inter-Container Communication:** We specified dependencies between services using the `depends_on` directive in the Docker Compose file. This ensures that containers are started in the correct order, with dependencies being resolved before dependent services start.

3. **Bridge Network Implementation:** Docker Compose by default creates a bridge network for the services defined in the `docker-compose.yml` file. In the Yolomy setup, the frontend, backend, and MongoDB containers are interconnected through this bridge network. The backend container, for example, can communicate with the MongoDB container using the service name `mongodb` as the hostname in its connection string (`mongodb://mongodb:27017/yolomy`). 

## Docker-Compose Volume Definition and Usage
### Volume Definition
In the Yolomy Docker Compose setup, volumes are defined for MongoDB and backend data:

- **MongoDB Volume:** A volume named `mongodb-data` is defined and mounted to `/data/db` within the MongoDB container. This volume ensures that MongoDB data persists across container restarts, preventing data loss.
- **Backend Data Volume:** A volume named `backend-data` is defined and mounted to `/backend/app/data` within the backend container. This volume stores data generated by the backend application, such as uploaded files or user sessions, ensuring data persistence and availability.

### Volume Usage
- The backend service specifies the `backend-data` volume and mounts it to the `/backend/app/data` directory within the container. This ensures that any data generated or stored within this directory is persisted externally, allowing for seamless data management and preservation.

## Git Workflow

We followed a typical Git workflow for developing and deploying the application. This includes creating feature branches for development, performing code reviews through pull requests, and merging changes into the main branch once reviewed and approved.

## Debugging Measures

If the applications fail to run successfully, we would review Docker logs using the commands `docker logs <container/image ID>`for any error messages and examine the Dockerfiles and Docker Compose file for misconfigurations. Additionally, we would check for any issues related to dependencies, environment variables, or networking configurations.

## Docker Image Tag Naming Standards

For easy identification and versioning of Docker images, we followed the convention of `<application_name>:tag`. We ensured that each Docker image is tagged with a descriptive name, such as `frontend:latest`, and `backend:1.0` to facilitate easy management and deployment.

## Yolo-App Deployment with Kubernetes
## Prerequisites

- Make sure [Kubernetes](https://kubernetes.io/) is installed
- Make sure [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) is configured
- Make sure the [AWSCLI](https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip) is installed and configured together with [eksctl](https://github.com/weaveworks/eksctl/releases/latest/download/eksctl)

**Steps to download AWS CLI on Linux**
```markdown
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
aws --version
```
**Steps to download eksctl on Linux**
```markdown
curl --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" -o "eksctl.tar.gz"
tar -xzf eksctl.tar.gz
sudo mv eksctl /usr/local/bin
eksctl version

```

## Deployment steps

1. **Apply MongoDB resources**:
``` markdown 
kubectl apply -f mongodb-statefulset.yml 
kubectl apply -f mongodb-service.yml 
```

2. **Apply Backend resources**:
``` markdown 
kubectl apply -f backend-deployment.yml
kubectl apply -f backend-service.yml
```

3. **Apply Frontend resources**:
``` markdown 
kubectl apply -f frontend-deployment.yml
kubectl apply -f frontend-service.yml
```

4. **Apply Mongo-Express resources**:
``` markdown 
 kubectl apply -f mongo-express-deployment.yml
 kubectl apply -f mongo-express-service.yml
```
5. **Apply Persistent Volume (pv) resources**:
``` markdown
kubectl apply -f pv.yml
```

6. **Apply Persistent Volume Claim (pvc)**:
```markdown
kubectl apply -f pvc.yml
```
## Reason for multiple cofiguration files for each servic
- **Modularity:** Separate YAML files make it easier to manage and maintain individual components. Each file focuses on a specific part of the application (e.g., frontend, backend, database).

- **Scalability:** With separate YAML files, each service can be scaled independently. For instance, if the backend requires more resources, we can scale it without affecting the frontend or the database.

- **Isolation:** Isolating configurations reduces the risk of errors. Changes to one service's configuration won't inadvertently affect another service.

- **Reusability:** Separate YAML files can be reused across different environments (e.g., development, staging, production) with minimal changes.



## Access the application
- Frontend: [Yolo-app](http://a2cd55b4cfb6d46a2a7f253d8c7476d8-530763216.us-west-2.elb.amazonaws.com/)
- Mongo Express: [Yolodb](http://aa9b277be2dd64233912349a23347468-1407590778.us-west-2.elb.amazonaws.com)
